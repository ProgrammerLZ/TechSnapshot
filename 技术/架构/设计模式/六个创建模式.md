## 一、工厂方法模式

>**简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。**

### 1.1 它要解决的问题是什么？

当一个类**A**的初始化方法接收了一个参数，这个参数用于区分应该如何构造自己的初始化数据。此时，这个类当中需要根据这个参数，进行大量的逻辑判断从而进行正确的初始化，随后，客户端（使用这个类的对象）根据返回的初始化对象对这个对象的方法进行一系列的调用。这里存在几个问题：

* 该类的初始化方法包含了大量的逻辑判断，使得类变得**冗长而不容易维护且影响性能**。
* 该类职责过重，初始化，以及对象的操作（方法）都在同一个类当中，**违反了单一职责原则**。
* 该类的初始化方法所接受的参数如果增加了一种情况，那么，必须修改该类的源代码，**违反了开闭原则**。
* 客户端如果通过**new**关键字进行创建该类的对象，则造成了客户端与该类**形成了一种强耦合关系**。 

工厂方法能够**在一定程度上**解决这些问题。

### 1.2 他是如何解决问题的？

简单工厂模式只能在一定程度上解决上述问题。

该模式通过三个类分饰不同的角色，这三个角色见1.4结构图。

* **ConcreteProduct**（实现单一职责原则）将类A当中的初始化方法的逻辑转换到不同的类当中，在这些类各自实现各自的初始化和操作，这样就解决了上述的第二个问题。
* **Factory**（实现客户端和该类的解耦）通过接收一个参数来判断应该返回哪个类型的**ConcreteProduct**。（这里好像并没有解决逻辑判断过多的问题）将本来由客户端进行创建对象的代码转义到了**Factory**当中，这就解决了客户端和该类强耦合的关系（解耦）。
* 个人觉得**Product**用于提供一个抽象层次的抽象类，从而在某些地方方便实现**里氏代换原则**，增加系统的灵活性。

### 1.3 在什么场景下可以使用它？

当所要创建的类抽象层次比较高的时候，并且会用到它的多种具象形态的时候，可以使用这种模式。比如，我要创建一个Animal类的时候，我可能会在这个类的初始化方法当中根据不同的参数对这个类进行初始化，从而构造该类的不同的具体形态，这个时候简单工厂模式特别适用。

### 1.4 结构图

![image-20180808174054231](/LZMac/Personal/Learn/笔记/架构设计/assets/image-20180808174054231.png)

* **Factory（工厂角色）：**工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法factoryMethod()，它的返回类型为抽象产品类型Product。
*  **Product（抽象产品角色）：**它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。
* **ConcreteProduct（具体产品角色）：**它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。

### 1.5 应用实例

iOS当中的NSNumber的一堆抽象方法。

### 1.6 优缺点

* 由于工厂类集中了所有产品的创建逻辑（if...else...），**职责过重**，维护和测试难度加大，一旦不能正常工作，整个系统都要受到影响。
* 使用简单工厂模式势必会增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度。
* 系统扩展困难，**一旦添加新产品就不得不修改工厂逻辑**，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。
* 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。



## 二、简单工厂模式

