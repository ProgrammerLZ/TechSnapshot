## 一、行为参数化

### 1.1 利用行为参数化来应对变化

先来看一段代码，这段代码的目的是通过颜色、重量两个维度来筛选苹果

```java
public static List<Apple> filterApples(List<Apple> inventory, String color, int weight, boolean flag) {
    List<Apple> result = new ArrayList<Apple>();
    for (Apple apple: inventory){
      if ( (flag && apple.getColor().equals(color)) || (!flag && apple.getWeight() > weight))			 { 
        result.add(apple);
      } 
		}
    return result;
}
```

可以说是一段极为恶心的代码，如果之后又加入了另外的维度来进行筛选，那么这段代码的判断将会越来越复杂，其缺点很明显**不能应对需求的变化**。

设计模式中有一种模式叫做**策略模式**能够解决这种问题，看看应用了策略模式后的代码

```java
public interface ApplePredicate{
        boolean test (Apple apple);
}
public class AppleHeavyWeightPredicate implements ApplePredicate{
		public boolean test(Apple apple){ 
         return apple.getWeight() > 150;
    }
}
public class AppleGreenColorPredicate implements ApplePredicate{
    public boolean test(Apple apple){
        return "green".equals(apple.getColor());
   } 
}
//很多参数被舍弃，换为一个谓词的参数
public static List<Apple> filterApples(List<Apple> inventory,ApplePredicate p){
    List<Apple> result = new ArrayList<>();
    for(Apple apple: inventory){
      if(p.test(apple)){
        result.add(apple);
      } 
    }
    return result;
}
```

策略模式将变化（筛选条件）封装起来，作为一个行为参数传递，改造后的**filterApples**代码非常的清晰。策略模式的重构方式很简单，就是将**行为参数化**而已。



### 1.2 跟啰嗦说再见

以上用策略模式进行代码优化的时候，需要创建很多的类，虽然代码变得灵活又清晰了但是也增加了工程当中类的数量，用起来也是需要先创建实现了谓词接口的类，然后将其实例化再传入filterApples，非常不直观并且啰嗦，我只是想把一个行为传入filterApples，却要那么麻烦，也太不直接了。接下来就要管理一下这种啰嗦的语法。

#### 1.2.1 使用内部类

```java
List<Apple> redApples = filterApples(inventory, new ApplePredicate() { 
	  public boolean test(Apple apple){
      return "red".equals(apple.getColor())
 	  }
);
 
```

#### 1.2.2 最终优化使用Lambda

```java
List<Apple> result =
filterApples(inventory, (Apple apple) -> "red".equals(apple.getColor()));
```

### 1.3 Lambda和方法引用实践

