#CPU
##寄存器
寄存器、运算器、控制器  
程序员通过改变寄存器的内容来实现对CPU的控制。  

物理地址：所有内存单元（存储单元）都有唯一的地址。  
8086 寄存器只有16位 数据总线也只有16位 却有20根地址总线   
解决方案：物理地址 = 段地址 * 16 + 偏移地址 通过地址加法器  

内存分段管理  
基地址（段地址）  
 
#汇编第三天
##第一段汇编代码
1.汇编指令：有对应机器码，有汇编器解析，最终被CPU执行。  
2.伪指令：没有对应机器码，由编译器解析，最终不被CPU执行。  
3.下面2句代码的作用是退出程序  

	mov ah,4ch  
	int 21h
	
##中断
1.硬中断  
回头理解  
2.软中断  
自己发给CPU的中断信号。  

##栈概念
概念：是一种具有特殊的访问方式存储空间（Last in Out First)  
真正的底层，栈是没有底这个概念的。  
SS(Stack Segment)：栈段的短地址。  
SP：栈的栈顶指针。

#汇编第四天
##代码分段
###8086伪指令
db （define byde)    
dw  (define word) 1word = 2*byte

###分段注意
除了代码段不需要用代码指定寄存器内容，其他段（ds、ss...）都需要在代码段中用代码去设置寄存器内容。  

###标号
假设标号为str,有如下代码

		str dw 20 dup(0)

str就代表这段数据。		  
标号 + ： 这个标号所代表的地址。（如：“str：”）  
offset 标号：表示这个标号的偏移（如：offset str)

###回忆
CS (Code Segment)：代码段寄存器  
	CS为代码段寄存器，IP为指令指针寄存器，它们指示了CPU当前要读取指令的地
DS (Data Segment)：数据段寄存器  
	要访问的数据段的地址，比如高级语言中的全局变量 
SS (Stack Segment)：堆栈段寄存器  
	比如高级语言中的局部变量  
	sp栈底指针
ES (Extra Segment)：附加段寄存器

##打印HelloWord
中断：  
	
	//打印
	mov ah,9h  
	int 21h
	
##Call&Ret指令
###指令介绍
* Call指令  
	将下一条指令的偏移地址入栈！  
	跳转到定位的地址执行指令！  
	
* ret指令
	将栈顶的值Pop给IP指令指针寄存器。  

这两个指令需要一起来使用。  


###关于汇编函数
**重中之重**    
    
 
**栈平衡**   

* 将栈中之前push进来的临时局部变量全部pop掉。
* 当在栈中进行寻址的时候，不能用sp去寻址，因为sp代表的是栈顶指针，他在逻辑意义上就是指向栈定的。可以通过把sp的值给bp，通过bp去进行堆栈寻址。  
* 当栈失衡的时候，会导致栈溢出（stackOverFlow），也就是内存泄漏。因此对象一定要有创建也有释放。  
* 栈平衡为了保证函数调用前后的栈顶是一致的。  
* 外平栈：函数外部保持栈平衡。  
* 内平栈：函数内部保证栈平衡。  
* 	Xcode中编译器会将OC编译为汇编。


#汇编第五天
##函数的局部变量
bp加 拿参数  
bp减 拿局部变量  
函数的调用流程  

* push参数（64位CPU任性使用寄存器）
* call指令调用（将下一条指令地址入栈）
* 保护bp寄存器，将sp赋值给bp
* 提升sp指针，作为局部变量控件（sp减去值）
* 保护寄存器（当函数内部使用了外部也在使用的寄存器）
* 业务逻辑
* 恢复寄存器
* 恢复sp （sp 指向 bp）
* 恢复bp （pop bp）
* 返回（ret ）


红色区域：（限定128个字节）当函数内部不再调用其他函数的时候，sp指针不会开辟一块局部变量的空间。直接利用bp指针移来存储局部变量和参数。  
栈帧：sp和bp之间的空间，也就是栈当中为局部变量开辟的空间。